#+TITLE: Emacs Tree-sitter

#+HUGO_BASE_DIR: .
#+HUGO_SECTION: /

# https://docdock.netlify.com/content-organisation/#unfolded-menu-entry-by-default
#+HUGO_CUSTOM_FRONT_MATTER: :alwaysopen true

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_TYPE: homepage
:END:

This is Emacs's binding for [[https://tree-sitter.github.io/][tree-sitter]], an incremental parsing system.

It aims to be the foundation for a new breed of Emacs packages that understand code structurally. For example:
- Faster, fine-grained code highlighting.
- More flexible code folding.
- Structural editing (like Paredit, or even better) for non-Lisp code.
- More informative indexing for imenu.

The author of tree-sitter articulated its merits a lot better in this [Strange Loop talk](https://www.thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html).

* Installation
:PROPERTIES:
:EXPORT_FILE_NAME: installation
:END:
~emacs-tree-sitter~ requires Emacs 25.1 or above, built with dynamic module support. Some Emacs distributions have this disabled by default. To check whether your Emacs has dynamic module support enabled, try evaluating one of these:

#+begin_src emacs-lisp
  (functionp 'module-load) ; should be t

  module-file-suffix ; should be non-nil
#+end_src

{{% notice note %}}The methods below only work for macOS, Windows, Linux on x86_64, since they download pre-compiled binaries. For other systems, you will have to build from source.{{% /notice %}}

** Installing from an ELPA
- Add tree-sitter's ELPA to ~package-archives~:
    #+begin_src emacs-lisp
      (add-to-list 'package-archives '("ublt" . "https://elpa.ubolonton.org/packages/"))
    #+end_src
- Run ~M-x package-refresh-contents~.
- Install ~tree-sitter~ and ~tree-sitter-langs~ packages.
- Add this to your config:
    #+begin_src emacs-lisp
      (require 'tree-sitter-langs)
    #+end_src

** Installing with straight.el
TODO

** Installing from Source
- Clone the source repo:
    #+begin_src sh
      git clone https://github.com/ubolonton/emacs-tree-sitter
    #+end_src

- Add its =lisp= and =langs= directories to ~load-path~:
    #+begin_src emacs-lisp
      (add-to-list 'load-path "/path-to/emacs-tree-sitter/lisp")
      (add-to-list 'load-path "/path-to/emacs-tree-sitter/langs")
    #+end_src

- Evaluate this to download the necessary binaries, /once/:
    #+begin_src emacs-lisp
      (require 'tree-sitter-langs-build)
      ;; Download pre-compiled `tree-sitter-dyn'.
      (tree-sitter-download-dyn-module)
    #+end_src

- Load the libraries in your config:
    #+begin_src emacs-lisp
      (require 'tree-sitter)
      (require 'tree-sitter-hl)
      (require 'tree-sitter-langs)
      (require 'tree-sitter-debug)
      (require 'tree-sitter-query)
    #+end_src

* Getting Started
:PROPERTIES:
:EXPORT_FILE_NAME: getting-started
:END:
** Tree-sitter Minor Mode
The minor mode ~tree-sitter-mode~ provides a buffer-local syntax tree, which is kept up-to-date with changes to the buffer's text.

It can be toggled in a buffer by the command ~tree-sitter-mode~, or enabled through major mode hooks:

#+begin_src emacs-lisp
  (add-hook 'rust-mode-hook #'tree-sitter-mode)
#+end_src

To enable in for all supported major modes:

#+begin_src emacs-lisp
  (global-tree-sitter-mode)
#+end_src

For a full list of supported major modes, check the variable ~tree-sitter-major-mode-language-alist~.

# ~tree-sitter-node-at-point~
# ~tree-sitter-save-excursion~

** Syntax Highlighting
The minor mode ~tree-sitter-hl-mode~ overrides the regex-based syntax highlighting provided by ~font-lock-mode~, using the syntax tree provided by ~tree-sitter-mode~.

It can be toggled in a buffer by the command ~tree-sitter-hl-mode~, or enabled through major mode hooks:

#+begin_src emacs-lisp
  (add-hook 'rust-mode-hook #'tree-sitter-hl-mode)
#+end_src

To enable it whenever possible:

#+begin_src emacs-lisp
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
#+end_src

# TODO: Example screenshots.

** View the Syntax Tree
Run ~M-x tree-sitter-debug-mode~ to show the current buffer's syntax tree in a separate buffer.

{{% notice warning %}}Printing the syntax tree can be slow for very large buffers, as it hasn't been optimized yet.{{% /notice %}}

# TODO: Example screenshots.

** Play around with Tree Queries
Run ~M-x tree-sitter-query-builder~ to open the query playground, where you can write tree queries and see matches highlighted in the source buffer.

Here are some example queries to try:

- Rust:
    #+begin_src scheme
      (function_item (identifier) @func)
      (impl_item (type_identifier) @impl)
    #+end_src
- Python:
    #+begin_src scheme
      (class_definition (identifier) @class)
      (function_definition (identifier) @func)
    #+end_src
- JavaScript:
    #+begin_src scheme
      (function_declaration (identifier) @func)
      (variable_declarator (identifier) @var)
    #+end_src

For more details on tree queries, see the [[*Querying][section on Queyring]].

# TODO: Example screenshots.

* Syntax Highlighting
** Custom Highlighting Patterns
- [ ] Customize tree-sitter-hl faces
- [ ] Use different faces for some capture names
- [ ] Use custom capture names
** Interface for Modes
- [ ] Major mode: tree-sitter-hl-default-patterns
- [ ] Minor mode: tree-sitter-hl-add-patterns
** Contributing Highlighting Patterns
- [ ] Set up a live env to see new patterns highlighted after saving =highlights.scm=.
* API Overview
:PROPERTIES:
:EXPORT_FILE_NAME: api-overview
:END:
** Naming Conventions
** Data Types
* Languages
** Loading Mechanism
** Language Mappings
** tree-sitter-langs
** Grammar Definitions
* Basic Operations
** Parsing
*** Parsing a String
*** Parsing with an Input Function
*** Incremental Parsing
** Inspecting
{{% alert theme="danger" %}}TODO: Explain node comparison and ts-node-eq{{% /alert %}}
*** Named vs. Anonymous Nodes
*** Node's Fields
** Walking
* Querying
:PROPERTIES:
:EXPORT_FILE_NAME: querying
:END:
** Query Syntax
*** Patterns
*** Fields
*** Anonymous Nodes
*** Captures
*** Predicates
** Examples
** Playground
* Advanced Topics
** Multi-language Buffers
** Compiling Binaries from Source
*** Main Package tree-sitter
*** Grammar Bundle tree-sitter-langs
** Creating a Language Grammar
* Scratch
** Basics
- Enable the ~tree-sitter~ minor mode in a supported major mode (defined in ~tree-sitter-major-mode-language-alist~):
    #+begin_src emacs-lisp
    (require 'tree-sitter)
    (require 'tree-sitter-langs)
    (add-hook 'rust-mode-hook #'tree-sitter-mode)
    #+end_src
- Show the debug view of a buffer's parse tree
    #+begin_src emacs-lisp
    (require 'tree-sitter-debug)
    (tree-sitter-debug-enable)
    #+end_src
- Get names of all functions in a Rust file:
    #+begin_src emacs-lisp
    (with-current-buffer "types.rs"
      (seq-map (lambda (capture)
                 (pcase-let ((`(_ . ,node) capture))
                   (ts-node-text node)))
               (tree-sitter-query [(function_item (identifier) @name)])))
    #+end_src
- Write a simple extension to ~expand-region~:
    #+begin_src emacs-lisp
    (defun tree-sitter-mark-next-bigger-node ()
      (interactive)
      (let* ((p (point))
             (m (if mark-active (mark) p))
             (beg (min p m))
             (end (max p m))
             (root (ts-root-node tree-sitter-tree))
             (node (ts-get-named-descendant-for-position-range root beg end))
             (node-beg (ts-node-start-position node))
             (node-end (ts-node-end-position node)))
        ;; Already marking current node. Try its parent node instead.
        (when (and (= beg node-beg) (= end node-end))
          (when-let ((node (ts-get-parent node)))
            (setq node-beg (ts-node-start-position node)
                  node-end (ts-node-end-position node))))
        (set-mark node-end)
        (goto-char node-beg)))
    #+end_src
- Parse a string:
    #+begin_src emacs-lisp
    (let ((parser (ts-make-parser)))
      (ts-set-language parser (tree-sitter-require 'rust))
      (ts-parse-string parser "fn foo() {}"))
    #+end_src
** Core API
*** _
- Functions in this package are named differently, to be more Lisp-idiomatic. The overall parsing flow stays the same.
- Documentation for individual functions can be viewed with ~C-h f~ (~describe-function~), as usual.
- A ~symbol~ in the C API is actually the ID of a type, so it's called ~type-id~ in this package.
*** Types
- ~language~, ~parser~, ~tree~, ~node~, ~cursor~, ~query~: corresponding tree-sitter types, embedded in ~user-ptr~ objects.
- ~point~: a pair of ~(LINE-NUMBER . BYTE-COLUMN)~.
  + ~LINE-NUMBER~ is the absolute line number returned by ~line-number-at-pos~, counting from 1.
  + ~BYTE-COLUMN~ counts from 0, like ~current-column~. However, unlike that function, it counts bytes, instead of displayed glyphs.
- ~range~: a vector in the form of ~[START-BYTEPOS END-BYTEPOS START-POINT END-POINT]~.

These types are understood only by this package. They are not recognized by ~type-of~, but have corresponding type-checking predicates, which are useful for debugging: ~ts-language-p~, ~ts-tree-p~, ~ts-node-p~...

For consistency with Emacs's conventions, this binding has some differences compared to the tree-sitter's C/Rust APIs:
- It uses 1-based byte positions, not 0-based byte offsets.
- It uses 1-based line numbers, not 0-based row coordinates.

*** Functions
- Language:
    + ~tree-sitter-require~: like ~require~, for tree-sitter languages.
- Parser:
    + ~ts-make-parser~: create a new parser.
    + ~ts-set-language~: set a parser's active language.
    + ~ts-parse-string~: parse a string.
    + ~ts-parse-chunks~: parse with a text-generating callback.
    + ~ts-set-included-ranges~: set sub-ranges when parsing multi-language text.
- Tree:
    + ~ts-root-node~: get the tree's root node.
    + ~ts-edit-tree~: prepare a tree for incremental parsing.
    + ~ts-changed-ranges~: compare 2 trees for changes.
    + ~ts-tree-to-sexp~: debug utility.
- Cursor:
    + ~ts-make-cursor~: obtain a new cursor from either a tree or a node.
    + ~ts-goto-~ functions: move to a different node.
    + ~ts-current-~ functions: get the current field/node.
- Node:
    + ~ts-node-~ functions: node's properties and predicates.
    + ~ts-get-~ functions: get related nodes (parent, siblings, children, descendants).
    + ~ts-count-~ functions: count child nodes.
    + ~ts-mapc-children~: loops through child nodes.
    + ~ts-node-to-sexp~: debug utility.
- Query:
    + ~ts-make-query~: create a new query.
    + ~ts-make-query-cursor~: create a new query cursor.
    + ~ts-query-matches~, ~ts-query-captures~: execute a query, returning matches/captures.
    + ~ts-set-byte-range~, ~ts-set-point-range~: limit query execution to a range.
