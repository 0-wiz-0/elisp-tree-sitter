use emacs::{defun, Result, GlobalRef, Value, Env};

use libloading::{Library, Symbol};
use once_cell::sync::Lazy;

use crate::types::*;
use std::collections::HashMap;
use std::sync::Mutex;

struct LangInfo {
    load_file: String,
    lang_symbol: GlobalRef,
    _lib: Library,
}

// TODO: Consider optimizing for accessing language's metadata, i.e. making Language a big wrapper
// around tree_sitter::Language, so that hash lookup happens only when returning the language of a
// parser/tree/node/query.
static LANG_INFOS: Lazy<Mutex<HashMap<usize, LangInfo>>> = Lazy::new(|| Mutex::new(HashMap::new()));

/// Load the shared lib FILE and return the language under SYMBOL-NAME.
/// The language's name symbol is set to LANG-SYMBOL.
#[defun]
fn _load_language(file: String, symbol_name: String, lang_symbol: Value) -> Result<Language> {
    let lib = Library::new(&file)?;
    let tree_sitter_lang: Symbol<'_, unsafe extern "C" fn() -> _> =
        unsafe { lib.get(symbol_name.as_bytes())? };
    let language: Language = unsafe { tree_sitter_lang() };
    LANG_INFOS.lock().expect("Failed to access language info registry").insert(language.id(), LangInfo {
        load_file: file,
        lang_symbol: lang_symbol.make_global_ref(),
        _lib: lib,
    });
    Ok(language)
}

fn _info(language: Language) -> Option<&'static LangInfo> {
    // TODO: Explain the safety.
    LANG_INFOS.lock().expect("Failed to access language info registry").get(&language.id())
        .map(|info| unsafe { erase_lifetime(info) })
}

/// Return LANGUAGE's name, as a symbol.
#[defun]
fn _lang_symbol(env: &Env, language: Language) -> Result<Option<Value>> {
    Ok(_info(language).map(|info| info.lang_symbol.bind(env)))
}

/// Return the shared lib file that LANGUAGE was loaded from.
#[defun]
fn _lang_load_file(language: Language) -> Result<Option<&'static String>> {
    Ok(_info(language).map(|info| &info.load_file))
}

macro_rules! defun_lang_methods {
    ($($(#[$meta:meta])* $($lisp_name:literal)? fn $name:ident $( ( $( $param:ident : $type:ty ),* ) )? -> $rtype:ty )*) => {
        $(
            #[defun$((name = $lisp_name))?]
            $(#[$meta])*
            fn $name(language: Language, $( $( $param : $type ),* )? ) -> Result<$rtype> {
                Ok((language.0).$name( $( $( $param ),* )? ))
            }
        )*
    };
}

defun_lang_methods! {
    /// Return the ABI version number for LANGUAGE.
    /// This version number is used to ensure that languages were generated by a
    /// compatible version of tree-sitter. `ts-set-language' will fail if the language
    /// is incompatible, so there's rarely a need to use this function, except for
    /// debugging purposes.
    "lang-version" fn version -> usize

    /// Return the number of distinct node types defined in LANGUAGE.
    "lang-count-types" fn node_kind_count -> usize

    /// Return the number of distinct field names defined in LANGUAGE.
    "lang-count-fields" fn field_count -> usize

    /// Return the name of a node type, given its numerical TYPE-ID in LANGUAGE.
    "type-name-for-id" fn node_kind_for_id(type_id: u16) -> Option<&'static str>

    /// Return t if the numerical TYPE-ID identifies a named node type in LANGUAGE.
    "type-named-p" fn node_kind_is_named(type_id: u16) -> bool

    /// Return the numerical id of FIELD-NAME in LANGUAGE.
    "field-id-for-name" fn field_id_for_name(field_name: String) -> Option<u16>

    /// Return the field name for the given numerical FIELD-ID defined in LANGUAGE.
    "field-name-for-id" fn field_name_for_id(field_id: u16) -> Option<&'static str>
}
